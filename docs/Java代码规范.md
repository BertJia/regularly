- model文件夹存放的为方法里所引用到的实体类，
- model里还可分为：dto、vo等，dto是mapper方法里引用相关联数据的类，vo则是用于表层传输的实体对象；
- VO 数据库存了10个字段，前端只需要3个字段，就封装一个XxxVO；
- DTO，数据库查了很多东西，比如两张表的或还有Redis中的数据或还有其他接口响应回来的数据，组装一个XxxDTO；
- 比如一个用户在页面操作数据，发出了一个请求。刚开始数据在页面上展示时候均为VO；VO 的数据是跟页面一一对应。VO在传到服务层之前，需要将VO转换成DTO再传给服务层。这里转DTO原因之前说了，比如页面有几十个字段，我只要其中几个。没有必要全部给我，所以是转DTO来传输。然后根据DTO传过来的数据，我们会构造出一个BO，也就是业务逻辑对象，一般在Business这个包。在BO这一段我们会完成具体的业务逻辑。业务逻辑完成后，数据你需要更新到数据库吧？所以，此时BO的数据就需要转换成对应的PO，因为一个PO对应一张表，所以需要用PO去完成数据的持久化。这就是整个前端到数据库的流程。
- 领域模型命名规约
     	1. 数据对象:xxxDO,xxx即为数据表名。
        	2. 数据传输对象:xxxDTO,xxx为业务领域相关的名称。
           	3. 展示对象:xxxVO,xxx一般为网页名称。
              	4. POJO是DO/DTO/BO/VO的统称,禁止命名成xxxPOJO。



__项目基本包：__	

com.company.{项目英文名（较长时适当简化）}.{模块名（可选）}config：配置类
startup：与服务启动相关的类
client：提供客户端实现的相关类
common：公共类，定义常量类，组件
entity: 数据库相关的实体类
     用于存放实体类，与数据库中的属性值基本一致，实现getter和setter方法。

     一般数据库一张表对应一个实体类，类属性同表字段一一对应。model:数据模型类(参数模型，数据传输模型等）
control:控制层接口
service: 服务层
dao：数据库访问层

1. entity 里的每一个字段，与数据库相对应，

2. vo 里的每一个字段，是和你前台 html 页面相对应，

3. dto 这是用来转换从 entity 到 vo，或者从 vo 到 entity 的中间的东西 。

**方法命名规范Mapper**
    简单的CRUD请按如下规则命名
    操作 例子 备注
    增加 insert
    删除 delete
    修改 update
    查询 select

**Service**
    简单的CRUD请按如下规则命名，其它操作请按业务动作命名，使用动词
    操作 例子 备注
    增加 add
    获取 get 获取到单条记录
    删除 delete
    更新 update 更新存在的记录
    保存 save 更新，不存在则新增
    查询 query 根据id等简单条件查询
    搜索 search 根据时间范围或模糊搜索